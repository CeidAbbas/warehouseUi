{"ast":null,"code":"import { __awaiter } from 'tslib';\nimport { AsyncSubject, BehaviorSubject } from 'rxjs';\nimport { Injectable, NgModule, defineInjectable, EventEmitter, Component, ViewChild, ViewEncapsulation } from '@angular/core';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/** @type {?} */\nimport * as ɵngcc0 from '@angular/core';\nconst _c0 = [\"video\"];\nconst _c1 = [\"canvas\"];\nconst _c2 = [\"resultsPanel\"];\nconst MEDIA_STREAM_DEFAULT = {\n  audio: false,\n  video: true\n};\n/** @type {?} */\nconst CONFIG_DEFAULT = {\n  src: '',\n  fps: 30,\n  vibrate: 300,\n  decode: 'utf-8',\n  isBeep: true,\n  deviceActive: 0,\n  constraints: MEDIA_STREAM_DEFAULT\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/**\r\n * OVERRIDES\r\n * \\@param variableKey\r\n * \\@param config\r\n * \\@param defaultConfig\r\n * \\@return\r\n * @type {?}\r\n */\nconst OVERRIDES =\n/**\r\n* @param {?} variableKey\r\n* @param {?} config\r\n* @param {?} defaultConfig\r\n* @return {?}\r\n*/\n(variableKey, config, defaultConfig) => {\n  if (config && Object.keys(config[variableKey]).length) {\n    for (const key in defaultConfig) {\n      /** @type {?} */\n      const cloneDeep = JSON.parse(JSON.stringify(Object.assign({}, config[variableKey], {\n        [key]: /** @type {?} */defaultConfig[key]\n      })));\n      config[variableKey] = config[variableKey].hasOwnProperty(key) ? config[variableKey] : cloneDeep;\n    }\n    return config[variableKey];\n  } else {\n    return defaultConfig;\n  }\n};\n/**\r\n * Rxjs complete\r\n * \\@param as\r\n * \\@param data\r\n * \\@param error\r\n * @type {?}\r\n */\nconst AS_COMPLETE =\n/**\r\n* @param {?} as\r\n* @param {?} data\r\n* @param {?=} error\r\n* @return {?}\r\n*/\n(as, data, error = null) => {\n  error ? as.error(error) : as.next(data);\n  as.complete();\n};\n/**\r\n * CAMERA_BEEP\r\n * \\@param isPlay\r\n * \\@return\r\n * @type {?}\r\n */\nconst PLAY_AUDIO =\n/**\r\n* @param {?=} isPlay\r\n* @return {?}\r\n*/\n(isPlay = false) => {\n  if (isPlay === false) return;\n  /** @type {?} */\n  const audio = new Audio('data:audio/wav;base64,UklGRl9vT19XQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YU' + Array(300).join('101'));\n  // when the sound has been loaded, execute your code\n  audio.oncanplaythrough =\n  /**\r\n  * @return {?}\r\n  */\n  () => {\n    /** @type {?} */\n    const promise = audio.play();\n    if (promise) {\n      promise.catch(\n      /**\r\n      * @param {?} e\r\n      * @return {?}\r\n      */\n      e => {\n        if (e.name === \"NotAllowedError\" || e.name === \"NotSupportedError\") ;\n      });\n    }\n  };\n};\n/**\r\n * HAS_OWN_PROPERTY\r\n * Fix issue vs ng v 6-7-8\r\n * Optional chaining (?.) just have on ng v 9++\r\n * eg: HAS_OWN_PROPERTY(config, 'frameOptions.style') // output: boolean\r\n * \\@param obj\r\n * \\@param propertyPath\r\n * \\@return\r\n * @type {?}\r\n */\nconst HAS_OWN_PROPERTY =\n/**\r\n* @param {?} obj\r\n* @param {?} propertyPath\r\n* @return {?}\r\n*/\n(obj, propertyPath) => {\n  /** @type {?} */\n  const properties = propertyPath.split(\".\");\n  for (let i = 0; i < properties.length; i++) {\n    /** @type {?} */\n    let prop = properties[i];\n    if (!obj.hasOwnProperty(prop)) {\n      return false;\n    } else {\n      obj = obj[prop];\n    }\n  }\n  return true;\n};\n/**\r\n * DRAW_RESULT_APPEND_CHILD\r\n * \\@param code\r\n * \\@param oriCanvas\r\n * \\@param elTarget\r\n * @type {?}\r\n */\nconst DRAW_RESULT_APPEND_CHILD =\n/**\r\n* @param {?} code\r\n* @param {?} oriCanvas\r\n* @param {?} elTarget\r\n* @return {?}\r\n*/\n(code, oriCanvas, elTarget) => {\n  /** @type {?} */\n  let widthZoom;\n  /** @type {?} */\n  let heightZoom;\n  /** @type {?} */\n  let oriWidth = oriCanvas.width;\n  /** @type {?} */\n  let oriHeight = oriCanvas.height;\n  /** @type {?} */\n  let oriWHRatio = oriWidth / oriHeight;\n  /** @type {?} */\n  let imgWidth = parseInt(getComputedStyle(oriCanvas).width);\n  /** @type {?} */\n  let imgHeight = parseInt(getComputedStyle(oriCanvas).height);\n  /** @type {?} */\n  let imgWHRatio = imgWidth / imgHeight;\n  elTarget.innerHTML = '';\n  if (oriWHRatio > imgWHRatio) {\n    widthZoom = imgWidth / oriWidth;\n    heightZoom = imgWidth / oriWHRatio / oriHeight;\n  } else {\n    heightZoom = imgHeight / oriHeight;\n    widthZoom = imgHeight * oriWHRatio / oriWidth;\n  }\n  for (let i = 0; i < code.length; i++) {\n    /** @type {?} */\n    const _code = code[i];\n    // New canvas\n    /** @type {?} */\n    let cvs = document.createElement(\"canvas\");\n    /** @type {?} */\n    let ctx = /** @type {?} */cvs.getContext('2d', {\n      willReadFrequently: true\n    });\n    /** @type {?} */\n    let loc = {};\n    /** @type {?} */\n    let X = [];\n    /** @type {?} */\n    let Y = [];\n    // Point x,y\n    /** @type {?} */\n    const points = _code.points;\n    for (let j = 0; j < points.length; j++) {\n      /** @type {?} */\n      const xj = HAS_OWN_PROPERTY(points, `${j}.x`) ? points[j].x : 0;\n      /** @type {?} */\n      const yj = HAS_OWN_PROPERTY(points, `${j}.y`) ? points[j].y : 0;\n      loc[`x${j + 1}`] = xj;\n      loc[`y${j + 1}`] = yj;\n      X.push(xj);\n      Y.push(yj);\n    }\n    // Min max\n    /** @type {?} */\n    let maxX = Math.max(...X);\n    /** @type {?} */\n    let minX = Math.min(...X);\n    /** @type {?} */\n    let maxY = Math.max(...Y);\n    /** @type {?} */\n    let minY = Math.min(...Y);\n    // Add class\n    cvs.setAttribute('class', 'qrcode-polygon');\n    // Size with screen zoom\n    if (oriWHRatio > imgWHRatio) {\n      cvs.style.top = minY * heightZoom + (imgHeight - imgWidth / oriWHRatio) * 0.5 + \"px\";\n      cvs.style.left = minX * widthZoom + \"px\";\n      cvs.width = (maxX - minX) * widthZoom;\n      cvs.height = (maxY - minY) * widthZoom;\n    } else {\n      cvs.style.top = minY * heightZoom + \"px\";\n      cvs.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + \"px\";\n      cvs.width = (maxX - minX) * heightZoom;\n      cvs.height = (maxY - minY) * heightZoom;\n    }\n    // Style for canvas\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'green';\n    ctx.fillStyle = \"#55f02880\";\n    // polygon [x,y, x,y, x,y.....];\n    /** @type {?} */\n    const polygon = [];\n    for (let k = 0; k < X.length; k++) {\n      polygon.push((loc[`x${k + 1}`] - minX) * heightZoom);\n      polygon.push((loc[`y${k + 1}`] - minY) * widthZoom);\n    }\n    // Copy array\n    /** @type {?} */\n    const shape = /** @type {?} */polygon.slice(0);\n    // Draw polygon\n    ctx.beginPath();\n    ctx.moveTo(shape.shift(), shape.shift());\n    while (shape.length) {\n      ctx.lineTo(shape.shift(), shape.shift()); //x,y\n    }\n\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n    // Tooltip result\n    /** @type {?} */\n    const qrcodeTooltipTemp = document.createElement('div');\n    qrcodeTooltipTemp.setAttribute('class', 'qrcode-tooltip-temp');\n    qrcodeTooltipTemp.innerText = _code.value;\n    // Tooltip box\n    /** @type {?} */\n    const qrcodeTooltip = document.createElement('div');\n    qrcodeTooltip.setAttribute('class', 'qrcode-tooltip');\n    qrcodeTooltip.appendChild(qrcodeTooltipTemp);\n    heightZoom = imgHeight / oriHeight;\n    widthZoom = imgHeight * oriWHRatio / oriWidth;\n    qrcodeTooltip.style.fontSize = widthZoom * 15 + 'px';\n    qrcodeTooltip.style.top = minY * heightZoom + \"px\";\n    qrcodeTooltip.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + \"px\";\n    qrcodeTooltip.style.width = (maxX - minX) * heightZoom + \"px\";\n    qrcodeTooltip.style.height = (maxY - minY) * heightZoom + \"px\";\n    // Result text\n    /** @type {?} */\n    const resultText = document.createElement('span');\n    resultText.innerText = _code.value;\n    resultText.style.fontSize = widthZoom * 13 + 'px';\n    // Set position result text\n    resultText.style.top = minY * heightZoom + -20 * heightZoom + \"px\";\n    resultText.style.left = minX * widthZoom + (imgWidth - imgHeight * oriWHRatio) * 0.5 + \"px\";\n    if (elTarget) {\n      elTarget.appendChild(qrcodeTooltip);\n      elTarget.appendChild(resultText);\n      elTarget.appendChild(cvs);\n    }\n  }\n}\n/**\r\n * DRAW_RESULT_ON_CANVAS\r\n * @param code\r\n * @param cvs\r\n */;\n/**\r\n * DRAW_RESULT_ON_CANVAS\r\n * \\@param code\r\n * \\@param cvs\r\n * @type {?}\r\n */\nconst DRAW_RESULT_ON_CANVAS =\n/**\r\n* @param {?} code\r\n* @param {?} cvs\r\n* @return {?}\r\n*/\n(code, cvs) => {\n  /** @type {?} */\n  let ctx = /** @type {?} */cvs.getContext('2d', {\n    willReadFrequently: true\n  });\n  for (let i = 0; i < code.length; i++) {\n    /** @type {?} */\n    const _code = code[i];\n    /** @type {?} */\n    let loc = {};\n    /** @type {?} */\n    let X = [];\n    /** @type {?} */\n    let Y = [];\n    // Point x,y\n    /** @type {?} */\n    const points = _code.points;\n    for (let j = 0; j < points.length; j++) {\n      /** @type {?} */\n      const xj = HAS_OWN_PROPERTY(points, `${j}.x`) ? points[j].x : 0;\n      /** @type {?} */\n      const yj = HAS_OWN_PROPERTY(points, `${j}.y`) ? points[j].y : 0;\n      loc[`x${j + 1}`] = xj;\n      loc[`y${j + 1}`] = yj;\n      X.push(xj);\n      Y.push(yj);\n    }\n    // Min max\n    /** @type {?} */\n    let minX = Math.min(...X);\n    /** @type {?} */\n    let minY = Math.min(...Y);\n    // Style for canvas\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = 'green';\n    ctx.fillStyle = \"#55f02880\";\n    ctx.font = \"15px serif\";\n    FILL_TEXT_MULTI_LINE(ctx, _code.value, minX, minY - 5);\n    // polygon [x,y, x,y, x,y.....];\n    /** @type {?} */\n    const polygon = [];\n    for (let k = 0; k < X.length; k++) {\n      polygon.push(loc[`x${k + 1}`]);\n      polygon.push(loc[`y${k + 1}`]);\n    }\n    // Copy array\n    /** @type {?} */\n    const shape = /** @type {?} */polygon.slice(0);\n    // Draw polygon\n    ctx.beginPath();\n    ctx.moveTo(shape.shift(), shape.shift());\n    while (shape.length) {\n      ctx.lineTo(shape.shift(), shape.shift()); //x,y\n    }\n\n    ctx.closePath();\n    ctx.fill();\n    ctx.stroke();\n  }\n}\n/**\r\n * READ_AS_DATA_URL\r\n * @param file\r\n * @param config\r\n * @return Promise\r\n */;\n/**\r\n * READ_AS_DATA_URL\r\n * \\@param file\r\n * \\@param config\r\n * \\@return Promise\r\n * @type {?}\r\n */\nconst READ_AS_DATA_URL =\n/**\r\n* @param {?} file\r\n* @param {?} config\r\n* @return {?}\r\n*/\n(file, config) => {\n  /**\r\n   * overrides *\r\n   * @type {?}\r\n   */\n  let decode = HAS_OWN_PROPERTY(config, 'decode') ? config.decode : CONFIG_DEFAULT.decode;\n  /** drawImage **/\n  return new Promise(\n  /**\r\n  * @param {?} resolve\r\n  * @param {?} reject\r\n  * @return {?}\r\n  */\n  (resolve, reject) => {\n    /** @type {?} */\n    const fileReader = new FileReader();\n    fileReader.onload =\n    /**\r\n    * @return {?}\r\n    */\n    () => {\n      /** @type {?} */\n      const objectFile = {\n        name: file.name,\n        file: file,\n        url: URL.createObjectURL(file)\n      };\n      // Set the src of this Image object.\n      /** @type {?} */\n      const image = new Image();\n      // Setting cross origin value to anonymous\n      image.setAttribute('crossOrigin', 'anonymous');\n      // When our image has loaded.\n      image.onload =\n      /**\r\n      * @return {?}\r\n      */\n      () => __awaiter(this, void 0, void 0, function* () {\n        // Get the canvas element by using the getElementById method.\n        /** @type {?} */\n        const canvas = document.createElement('canvas');\n        // HTMLImageElement size\n        canvas.width = image.naturalWidth || image.width;\n        canvas.height = image.naturalHeight || image.height;\n        // Get a 2D drawing context for the canvas.\n        /** @type {?} */\n        const ctx = /** @type {?} */canvas.getContext('2d');\n        // Draw image\n        ctx.drawImage(image, 0, 0, canvas.width, canvas.height);\n        // Data image\n        /** @type {?} */\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Scanner\n        /** @type {?} */\n        const code = yield zbarWasm.scanImageData(imageData);\n        if (code && code.length) {\n          // Decode\n          code.forEach(\n          /**\r\n          * @param {?} s\r\n          * @return {?}\r\n          */\n          s => s.value = s.decode(decode && decode.toLocaleLowerCase()));\n          // Overlay\n          DRAW_RESULT_ON_CANVAS(code, canvas);\n          // Emit object\n          /** @type {?} */\n          const blob = yield CANVAS_TO_BLOB(canvas);\n          /** @type {?} */\n          const url = URL.createObjectURL(blob);\n          /** @type {?} */\n          const blobToFile =\n          /**\r\n          * @param {?} theBlob\r\n          * @param {?} fileName\r\n          * @return {?}\r\n          */\n          (theBlob, fileName) => new File([theBlob], fileName, {\n            lastModified: new Date().getTime(),\n            type: theBlob.type\n          });\n          resolve(Object.assign({}, objectFile, {\n            data: code,\n            url: url,\n            canvas: canvas,\n            file: blobToFile(blob, objectFile.name)\n          }));\n        } else {\n          resolve(Object.assign({}, objectFile, {\n            data: code,\n            canvas: canvas\n          }));\n        }\n      });\n      // Set src\n      image.src = objectFile.url;\n    };\n    fileReader.onerror =\n    /**\r\n    * @param {?} error\r\n    * @return {?}\r\n    */\n    error => reject(error);\n    fileReader.readAsDataURL(file);\n  });\n}\n/**\r\n * Convert canvas to blob\r\n * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality\r\n * @param canvas\r\n * @param type\r\n * @return Promise\r\n */;\n/**\r\n * Convert canvas to blob\r\n * canvas.toBlob((blob) => { .. }, 'image/jpeg', 0.95); // JPEG at 95% quality\r\n * \\@param canvas\r\n * \\@param type\r\n * \\@return Promise\r\n * @type {?}\r\n */\nconst CANVAS_TO_BLOB =\n/**\r\n* @param {?} canvas\r\n* @param {?=} type\r\n* @return {?}\r\n*/\n(canvas, type) => {\n  return new Promise(\n  /**\r\n  * @param {?} resolve\r\n  * @param {?} reject\r\n  * @return {?}\r\n  */\n  (resolve, reject) => canvas.toBlob(\n  /**\r\n  * @param {?} blob\r\n  * @return {?}\r\n  */\n  blob => resolve(blob), type));\n}\n/**\r\n * Convert blob to file\r\n * @param theBlob\r\n * @param fileName\r\n * @return File\r\n */;\n/**\r\n * Convert blob to file\r\n * \\@param theBlob\r\n * \\@param fileName\r\n * \\@return File\r\n * @type {?}\r\n */\nconst BLOB_TO_FILE =\n/**\r\n* @param {?} theBlob\r\n* @param {?} fileName\r\n* @return {?}\r\n*/\n(theBlob, fileName) => {\n  return new File([theBlob], fileName, {\n    lastModified: new Date().getTime(),\n    type: theBlob.type\n  });\n}\n/**\r\n * FILES_TO_SCAN\r\n * @param files\r\n * @return AsyncSubject\r\n */;\n/**\r\n * FILES_TO_SCAN\r\n * \\@param files\r\n * \\@return AsyncSubject\r\n * @type {?}\r\n */\nconst FILES_TO_SCAN =\n/**\r\n* @param {?=} files\r\n* @param {?=} configs\r\n* @param {?=} as\r\n* @return {?}\r\n*/\n(files = [], configs, as = new AsyncSubject()) => {\n  Promise.all(Object.assign([], files).map(\n  /**\r\n  * @param {?} m\r\n  * @return {?}\r\n  */\n  m => READ_AS_DATA_URL(m, configs))).then(\n  /**\r\n  * @param {?} img\r\n  * @return {?}\r\n  */\n  img => AS_COMPLETE(as, img)).catch(\n  /**\r\n  * @param {?} error\r\n  * @return {?}\r\n  */\n  error => AS_COMPLETE(as, null, error));\n  return as;\n}\n/**\r\n * FILL_TEXT_MULTI_LINE\r\n * @param ctx\r\n * @param text\r\n * @param x\r\n * @param y\r\n */;\n/**\r\n * FILL_TEXT_MULTI_LINE\r\n * \\@param ctx\r\n * \\@param text\r\n * \\@param x\r\n * \\@param y\r\n * @type {?}\r\n */\nconst FILL_TEXT_MULTI_LINE =\n/**\r\n* @param {?} ctx\r\n* @param {?} text\r\n* @param {?} x\r\n* @param {?} y\r\n* @return {?}\r\n*/\n(ctx, text, x, y) => {\n  /** @type {?} */\n  let lineHeight = ctx.measureText(\"M\").width * 1.2;\n  /** @type {?} */\n  let lines = text.split(\"\\n\");\n  for (var i = 0; i < lines.length; ++i) {\n    ctx.fillText(lines[i], x, y);\n    ctx.strokeText(lines[i], x, y);\n    y += lineHeight;\n  }\n}\n/**\r\n * VIBRATE\r\n * Bật rung trên mobile\r\n * @param time\r\n */;\n/**\r\n * VIBRATE\r\n * Bật rung trên mobile\r\n * \\@param time\r\n * @type {?}\r\n */\nconst VIBRATE =\n/**\r\n* @param {?} time\r\n* @return {?}\r\n*/\ntime => {\n  time && IS_MOBILE() && window.navigator.vibrate(time);\n};\n/**\r\n * IS_MOBILE\r\n * \\@return\r\n * @type {?}\r\n */\nconst IS_MOBILE =\n/**\r\n* @return {?}\r\n*/\n() => {\n  /** @type {?} */\n  const vendor = navigator.userAgent || navigator['vendor'] || window['opera'];\n  return !!(/(android|bb\\d+|meego).+mobile|avantgo|bada\\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(vendor) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(vendor.substr(0, 4)));\n};\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nclass NgxScannerQrcodeService {\n  /**\r\n   * Load files\r\n   * @param {?=} files\r\n   * @return {?} AsyncSubject\r\n   */\n  loadFiles(files = []) {\n    /** @type {?} */\n    const as = new AsyncSubject();\n    Promise.all(Object.assign([], files).map(\n    /**\r\n    * @param {?} m\r\n    * @return {?}\r\n    */\n    m => this.readAsDataURL(m))).then(\n    /**\r\n    * @param {?} img\r\n    * @return {?}\r\n    */\n    img => AS_COMPLETE(as, img)).catch(\n    /**\r\n    * @param {?} error\r\n    * @return {?}\r\n    */\n    error => AS_COMPLETE(as, null, error));\n    return as;\n  }\n  /**\r\n   * loadFilesToScan\r\n   * @param {?=} files\r\n   * @param {?=} config\r\n   * @return {?}\r\n   */\n  loadFilesToScan(files = [], config) {\n    return FILES_TO_SCAN(files, config);\n  }\n  /**\r\n   * readAsDataURL\r\n   * @private\r\n   * @param {?} file\r\n   * @return {?} Promise\r\n   */\n  readAsDataURL(file) {\n    /** drawImage **/\n    return new Promise(\n    /**\r\n    * @param {?} resolve\r\n    * @param {?} reject\r\n    * @return {?}\r\n    */\n    (resolve, reject) => {\n      /** @type {?} */\n      const fileReader = new FileReader();\n      fileReader.onload =\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        /** @type {?} */\n        const objectFile = {\n          name: file.name,\n          file: file,\n          url: URL.createObjectURL(file)\n        };\n        resolve(objectFile);\n      };\n      fileReader.onerror =\n      /**\r\n      * @param {?} error\r\n      * @return {?}\r\n      */\n      error => reject(error);\n      fileReader.readAsDataURL(file);\n    });\n  }\n}\nNgxScannerQrcodeService.ɵfac = function NgxScannerQrcodeService_Factory(t) {\n  return new (t || NgxScannerQrcodeService)();\n};\nNgxScannerQrcodeService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n  token: NgxScannerQrcodeService,\n  factory: NgxScannerQrcodeService.ɵfac,\n  providedIn: 'root'\n});\n/** @nocollapse */\nNgxScannerQrcodeService.ngInjectableDef = defineInjectable({\n  factory: function NgxScannerQrcodeService_Factory() {\n    return new NgxScannerQrcodeService();\n  },\n  token: NgxScannerQrcodeService,\n  providedIn: \"root\"\n});\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nlet NgxScannerQrcodeComponent = /*#__PURE__*/(() => {\n  class NgxScannerQrcodeComponent {\n    constructor() {\n      /**\r\n       * EventEmitter\r\n       */\n      this.event = new EventEmitter();\n      /**\r\n       * Input\r\n       */\n      this.src = CONFIG_DEFAULT.src;\n      this.fps = CONFIG_DEFAULT.fps;\n      this.vibrate = CONFIG_DEFAULT.vibrate;\n      this.decode = CONFIG_DEFAULT.decode;\n      this.isBeep = CONFIG_DEFAULT.isBeep;\n      this.deviceActive = CONFIG_DEFAULT.deviceActive;\n      this.config = CONFIG_DEFAULT;\n      this.constraints = CONFIG_DEFAULT.constraints;\n      /**\r\n       * Export\r\n       */\n      this.isStart = false;\n      this.isLoading = false;\n      this.isTorch = false;\n      this.data = new BehaviorSubject([]);\n      this.devices = new BehaviorSubject([]);\n      this.dataForResize = [];\n    }\n    /**\r\n     * @return {?}\r\n     */\n    ngOnInit() {\n      this.overrideConfig();\n      if (this.src) {\n        this.loadImage(this.src);\n      }\n      this.resize();\n    }\n    /**\r\n     * start\r\n     * @return {?} AsyncSubject\r\n     */\n    start() {\n      /** @type {?} */\n      const as = new AsyncSubject();\n      if (this.isStart) {\n        // Reject\n        AS_COMPLETE(as, false);\n      } else {\n        // mediaDevices\n        this.loadAllDevices(as);\n      }\n      return as;\n    }\n    /**\r\n     * playDevice\r\n     * @param {?} deviceId\r\n     * @param {?=} as\r\n     * @return {?} AsyncSubject\r\n     */\n    playDevice(deviceId, as = new AsyncSubject()) {\n      /** @type {?} */\n      const existDeviceId = this.isStart ? this.getConstraints().deviceId != deviceId : true;\n      switch (true) {\n        case deviceId == 'null' || deviceId == null:\n          this.stop();\n          AS_COMPLETE(as, false);\n          break;\n        case deviceId && existDeviceId:\n          stop();\n          this.stop();\n          clearInterval(this.rAF_ID);\n          // Loading on\n          this.status(false, true);\n          /** @type {?} */\n          const constraints = {\n            audio: false,\n            video: typeof (this.constraints && this.constraints.video) === 'boolean' ? {\n              deviceId: deviceId\n            } : Object.assign({\n              deviceId: deviceId\n            }, this.constraints && this.constraints.video)\n          };\n          this.deviceActive = this.devices.value.findIndex(\n          /**\r\n          * @param {?} f\r\n          * @return {?}\r\n          */\n          f => f.deviceId == deviceId);\n          // MediaStream\n          navigator.mediaDevices.getUserMedia(constraints).then(\n          /**\r\n          * @param {?} stream\r\n          * @return {?}\r\n          */\n          stream => {\n            this.video.nativeElement.srcObject = stream;\n            this.video.nativeElement.onloadedmetadata =\n            /**\r\n            * @return {?}\r\n            */\n            () => {\n              this.video.nativeElement.play();\n              this.requestAnimationFrame();\n              this.status(true, false);\n              AS_COMPLETE(as, true);\n            };\n          }).catch(\n          /**\r\n          * @param {?} error\r\n          * @return {?}\r\n          */\n          error => {\n            this.status(false, false);\n            this.eventEmit(false);\n            AS_COMPLETE(as, false, error);\n          });\n          break;\n        default:\n          AS_COMPLETE(as, false);\n          break;\n      }\n      return as;\n    }\n    /**\r\n     * stop\r\n     * @return {?} AsyncSubject\r\n     */\n    stop() {\n      this.eventEmit(null);\n      this.status(false, false);\n      /** @type {?} */\n      const as = new AsyncSubject();\n      try {\n        this.removeCanvas();\n        clearInterval(this.rAF_ID);\n        /** @type {?} */this.video.nativeElement.srcObject.getTracks().forEach(\n        /**\r\n        * @param {?} track\r\n        * @return {?}\r\n        */\n        track => {\n          track.stop();\n          AS_COMPLETE(as, true);\n        });\n      } catch (error) {\n        AS_COMPLETE(as, false, /** @type {?} */error);\n      }\n      return as;\n    }\n    /**\r\n     * play\r\n     * @return {?} AsyncSubject\r\n     */\n    play() {\n      /** @type {?} */\n      const as = new AsyncSubject();\n      if (this.isPause) {\n        this.video.nativeElement.play();\n        this.requestAnimationFrame();\n        AS_COMPLETE(as, true);\n      } else {\n        AS_COMPLETE(as, false);\n      }\n      return as;\n    }\n    /**\r\n     * pause\r\n     * @return {?} AsyncSubject\r\n     */\n    pause() {\n      /** @type {?} */\n      const as = new AsyncSubject();\n      if (this.isStart) {\n        clearInterval(this.rAF_ID);\n        this.video.nativeElement.pause();\n        AS_COMPLETE(as, true);\n      } else {\n        AS_COMPLETE(as, false);\n      }\n      return as;\n    }\n    /**\r\n     * loadImage\r\n     * @param {?} src\r\n     * @return {?} AsyncSubject\r\n     */\n    loadImage(src) {\n      /** @type {?} */\n      const as = new AsyncSubject();\n      // Loading on\n      this.status(false, true);\n      // Set the src of this Image object.\n      /** @type {?} */\n      const image = new Image();\n      // Setting cross origin value to anonymous\n      image.setAttribute('crossOrigin', 'anonymous');\n      // When our image has loaded.\n      image.onload =\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        this.drawImage(image,\n        /**\r\n        * @param {?} flag\r\n        * @return {?}\r\n        */\n        flag => {\n          this.status(false, false);\n          AS_COMPLETE(as, flag);\n        });\n      };\n      // Set src\n      image.src = src;\n      return as;\n    }\n    /**\r\n     * torcher\r\n     * @return {?} AsyncSubject\r\n     */\n    torcher() {\n      /** @type {?} */\n      const as = this.applyConstraints({\n        torch: this.isTorch\n      });\n      as.subscribe(\n      /**\r\n      * @return {?}\r\n      */\n      () => false,\n      /**\r\n      * @return {?}\r\n      */\n      () => this.isTorch = !this.isTorch);\n      return as;\n    }\n    /**\r\n     * applyConstraints\r\n     * @param {?} constraints\r\n     * @return {?} AsyncSubject\r\n     */\n    applyConstraints(constraints) {\n      /** @type {?} */\n      const as = new AsyncSubject();\n      /** @type {?} */\n      const stream = /** @type {?} */this.video.nativeElement.srcObject;\n      /** @type {?} */\n      const videoTrack = /** @type {?} */stream.getVideoTracks()[0];\n      /** @type {?} */\n      const imageCapture = new /** @type {?} */window.ImageCapture(videoTrack);\n      imageCapture.getPhotoCapabilities().then(\n      /**\r\n      * @return {?}\r\n      */\n      () => __awaiter(this, void 0, void 0, function* () {\n        yield videoTrack.applyConstraints( /** @type {?} */{\n          advanced: [constraints]\n        });\n        AS_COMPLETE(as, true);\n      })).catch(\n      /**\r\n      * @param {?} error\r\n      * @return {?}\r\n      */\n      error => {\n        switch (error && error.name) {\n          case 'NotFoundError':\n          case 'DevicesNotFoundError':\n            AS_COMPLETE(as, false, /** @type {?} */'Required track is missing');\n            break;\n          case 'NotReadableError':\n          case 'TrackStartError':\n            AS_COMPLETE(as, false, /** @type {?} */'Webcam or mic are already in use');\n            break;\n          case 'OverconstrainedError':\n          case 'ConstraintNotSatisfiedError':\n            AS_COMPLETE(as, false, /** @type {?} */'Constraints can not be satisfied by avb. devices');\n            break;\n          case 'NotAllowedError':\n          case 'PermissionDeniedError':\n            AS_COMPLETE(as, false, /** @type {?} */'Permission denied in browser');\n            break;\n          case 'TypeError':\n            AS_COMPLETE(as, false, /** @type {?} */'Empty constraints object');\n            break;\n          default:\n            AS_COMPLETE(as, false, /** @type {?} */error);\n            break;\n        }\n      });\n      return as;\n    }\n    /**\r\n     * getConstraints\r\n     * @return {?}\r\n     */\n    getConstraints() {\n      /** @type {?} */\n      const stream = /** @type {?} */this.video.nativeElement.srcObject;\n      /** @type {?} */\n      const videoTrack = stream && /** @type {?} */stream.getVideoTracks()[0];\n      return videoTrack && /** @type {?} */videoTrack.getConstraints();\n    }\n    /**\r\n     * download\r\n     * @param {?=} fileName\r\n     * @return {?} AsyncSubject\r\n     */\n    download(fileName = `ngx-scanner-qrcode-${Date.now()}.png`) {\n      /** @type {?} */\n      const as = new AsyncSubject();\n      /** @type {?} */\n      const run =\n      /**\r\n      * @return {?}\r\n      */\n      () => __awaiter(this, void 0, void 0, function* () {\n        /** @type {?} */\n        const blob = yield CANVAS_TO_BLOB(this.canvas.nativeElement);\n        /** @type {?} */\n        const file = BLOB_TO_FILE(blob, fileName);\n        FILES_TO_SCAN([file], this.config, as).subscribe(\n        /**\r\n        * @param {?} res\r\n        * @return {?}\r\n        */\n        res => {\n          res.forEach(\n          /**\r\n          * @param {?} item\r\n          * @return {?}\r\n          */\n          item => {\n            /** @type {?} */\n            const link = document.createElement('a');\n            link.href = item.url;\n            link.download = item.name;\n            link.click();\n            link.remove();\n          });\n        });\n      });\n      run();\n      return as;\n    }\n    /**\r\n     * window: resize\r\n     * Draw again!\r\n     * @private\r\n     * @return {?}\r\n     */\n    resize() {\n      window.addEventListener(\"resize\",\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        if (this.dataForResize && this.dataForResize.length) {\n          DRAW_RESULT_APPEND_CHILD( /** @type {?} */this.dataForResize, this.canvas.nativeElement, this.resultsPanel.nativeElement);\n        }\n      });\n    }\n    /**\r\n     * Override config\r\n     * @private\r\n     * @return {?} void\r\n     */\n    overrideConfig() {\n      if (HAS_OWN_PROPERTY(this.config, 'src')) this.src = this.config.src;\n      if (HAS_OWN_PROPERTY(this.config, 'fps')) this.fps = this.config.fps;\n      if (HAS_OWN_PROPERTY(this.config, 'vibrate')) this.vibrate = this.config.vibrate;\n      if (HAS_OWN_PROPERTY(this.config, 'decode')) this.decode = this.config.decode;\n      if (HAS_OWN_PROPERTY(this.config, 'isBeep')) this.isBeep = this.config.isBeep;\n      if (HAS_OWN_PROPERTY(this.config, 'deviceActive')) this.deviceActive = this.config.deviceActive;\n      if (HAS_OWN_PROPERTY(this.config, 'constraints')) this.constraints = OVERRIDES('constraints', this.config, MEDIA_STREAM_DEFAULT);\n    }\n    /**\r\n     * loadAllDevices\r\n     * @private\r\n     * @param {?} as\r\n     * @return {?}\r\n     */\n    loadAllDevices(as) {\n      navigator.mediaDevices.enumerateDevices().then(\n      /**\r\n      * @param {?} devices\r\n      * @return {?}\r\n      */\n      devices => {\n        /** @type {?} */\n        let cameraDevices = [];\n        devices.forEach(\n        /**\r\n        * @param {?} f\r\n        * @return {?}\r\n        */\n        f => f.kind == 'videoinput' && cameraDevices.push(f));\n        this.devices.next(cameraDevices);\n        if (cameraDevices.length > 0) {\n          /** @type {?} */\n          const index = Math.max(0, cameraDevices.length > this.deviceActive ? this.deviceActive : 0);\n          this.playDevice(cameraDevices[index].deviceId, as);\n        } else {\n          AS_COMPLETE(as, false, /** @type {?} */'No camera detected.');\n        }\n      });\n    }\n    /**\r\n     * drawImage\r\n     * @private\r\n     * @param {?} element\r\n     * @param {?=} callback\r\n     * @return {?}\r\n     */\n    drawImage(element, callback =\n    /**\r\n    * @return {?}\r\n    */\n    () => {}) {\n      return __awaiter(this, void 0, void 0, function* () {\n        // Get the canvas element by using the getElementById method.\n        /** @type {?} */\n        const canvas = this.canvas.nativeElement;\n        // Get a 2D drawing context for the canvas.\n        /** @type {?} */\n        const ctx = /** @type {?} */canvas.getContext('2d', {\n          willReadFrequently: true\n        });\n        // HTMLImageElement size\n        if (element instanceof HTMLImageElement) {\n          canvas.width = element.naturalWidth;\n          canvas.height = element.naturalHeight;\n          element.style.visibility = '';\n          this.video.nativeElement.style.visibility = 'hidden';\n          this.video.nativeElement.style.height = canvas.offsetHeight + 'px';\n        }\n        // HTMLVideoElement size\n        if (element instanceof HTMLVideoElement) {\n          canvas.width = element.videoWidth;\n          canvas.height = element.videoHeight;\n          element.style.visibility = '';\n          this.canvas.nativeElement.style.visibility = 'hidden';\n        }\n        ctx.clearRect(0, 0, canvas.width, canvas.height);\n        // Draw image\n        ctx.drawImage(element, 0, 0, canvas.width, canvas.height);\n        // Data image\n        /** @type {?} */\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Draw frame\n        /** @type {?} */\n        const code = yield zbarWasm.scanImageData(imageData);\n        if (code && code.length) {\n          // Decode\n          code.forEach(\n          /**\r\n          * @param {?} s\r\n          * @return {?}\r\n          */\n          s => s.value = s.decode(this.decode && this.decode.toLocaleLowerCase()));\n          // Overlay\n          DRAW_RESULT_APPEND_CHILD(code, Object.freeze(this.canvas.nativeElement), this.resultsPanel.nativeElement);\n          // To blob and emit data\n          /** @type {?} */\n          const EMIT_DATA =\n          /**\r\n          * @return {?}\r\n          */\n          () => {\n            this.eventEmit(code);\n            this.dataForResize = code;\n          };\n          // HTMLImageElement\n          if (element instanceof HTMLImageElement) {\n            callback(true);\n            EMIT_DATA();\n            VIBRATE(this.vibrate);\n            PLAY_AUDIO(this.isBeep);\n          }\n          // HTMLVideoElement\n          if (element instanceof HTMLVideoElement) {\n            EMIT_DATA();\n            VIBRATE(this.vibrate);\n            PLAY_AUDIO(this.isBeep);\n          }\n        } else {\n          callback(false);\n          this.removeCanvas();\n          this.dataForResize = code;\n        }\n      });\n    }\n    /**\r\n     * removeCanvas\r\n     * @private\r\n     * @return {?}\r\n     */\n    removeCanvas() {\n      Object.assign([], this.resultsPanel.nativeElement.childNodes).forEach(\n      /**\r\n      * @param {?} el\r\n      * @return {?}\r\n      */\n      el => this.resultsPanel.nativeElement.removeChild(el));\n    }\n    /**\r\n     * status\r\n     * @private\r\n     * @param {?} isStart\r\n     * @param {?} isLoading\r\n     * @return {?}\r\n     */\n    status(isStart, isLoading) {\n      this.isStart = isStart;\n      this.isLoading = isLoading;\n    }\n    /**\r\n     * eventEmit\r\n     * @private\r\n     * @param {?=} response\r\n     * @return {?}\r\n     */\n    eventEmit(response = false) {\n      response !== false && this.data.next(response || {\n        data: null\n      });\n      response !== false && this.event.emit(response || {\n        data: null\n      });\n    }\n    /**\r\n     * Single-thread\r\n     * Loop Recording on Camera\r\n     * Must be destroy request\r\n     * Not using: requestAnimationFrame\r\n     * @private\r\n     * @return {?}\r\n     */\n    requestAnimationFrame() {\n      this.rAF_ID = setInterval(\n      /**\r\n      * @return {?}\r\n      */\n      () => {\n        if (this.video.nativeElement.readyState === this.video.nativeElement.HAVE_ENOUGH_DATA) {\n          this.drawImage(this.video.nativeElement);\n        }\n      }, this.fps);\n    }\n    /**\r\n     * Status of camera\r\n     * @return {?} boolean\r\n     */\n    get isPause() {\n      return this.isStart && this.video.nativeElement.paused;\n    }\n    /**\r\n     * @return {?}\r\n     */\n    ngOnDestroy() {\n      this.pause();\n    }\n  }\n  NgxScannerQrcodeComponent.ɵfac = function NgxScannerQrcodeComponent_Factory(t) {\n    return new (t || NgxScannerQrcodeComponent)();\n  };\n  NgxScannerQrcodeComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: NgxScannerQrcodeComponent,\n    selectors: [[\"ngx-scanner-qrcode\"]],\n    viewQuery: function NgxScannerQrcodeComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(_c0, 5);\n        ɵngcc0.ɵɵviewQuery(_c1, 5);\n        ɵngcc0.ɵɵviewQuery(_c2, 5);\n      }\n      if (rf & 2) {\n        let _t;\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.video = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.canvas = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.resultsPanel = _t.first);\n      }\n    },\n    hostAttrs: [1, \"ngx-scanner-qrcode\"],\n    inputs: {\n      src: \"src\",\n      fps: \"fps\",\n      vibrate: \"vibrate\",\n      decode: \"decode\",\n      isBeep: \"isBeep\",\n      deviceActive: \"deviceActive\",\n      config: \"config\",\n      constraints: \"constraints\"\n    },\n    outputs: {\n      event: \"event\"\n    },\n    exportAs: [\"scanner\"],\n    decls: 6,\n    vars: 0,\n    consts: [[1, \"origin-overlay\"], [\"resultsPanel\", \"\"], [1, \"origin-canvas\"], [\"canvas\", \"\"], [\"playsinline\", \"\", 1, \"origin-video\"], [\"video\", \"\"]],\n    template: function NgxScannerQrcodeComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵelement(0, \"div\", 0, 1)(2, \"canvas\", 2, 3)(4, \"video\", 4, 5);\n      }\n    },\n    styles: [\".ngx-scanner-qrcode{display:block;position:relative}.origin-overlay{width:100%;position:absolute}.origin-overlay span{z-index:2;color:red;text-align:left;position:absolute}.origin-overlay .qrcode-polygon{z-index:1;position:absolute}.origin-canvas{width:100%;position:absolute}.origin-video{width:100%;background-color:#262626}.qrcode-tooltip{z-index:3;position:absolute}.qrcode-tooltip:hover .qrcode-tooltip-temp{display:block;position:absolute}.qrcode-tooltip-temp{bottom:0;left:50%;padding:5px;color:#fff;text-align:left;display:none;max-width:450px;border-radius:5px;width:-moz-max-content;width:max-content;word-wrap:break-word;transform:translate(-50%);transform-style:preserve-3d;background-color:#000000d0;box-shadow:1px 1px 20px #000000e0}\"],\n    encapsulation: 2\n  });\n  return NgxScannerQrcodeComponent;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n/** @enum {number} */\nconst ScannerQRCodeSymbolType = {\n  ScannerQRCode_NONE: 0,\n  ScannerQRCode_PARTIAL: 1,\n  ScannerQRCode_EAN2: 2,\n  ScannerQRCode_EAN5: 5,\n  ScannerQRCode_EAN8: 8,\n  ScannerQRCode_UPCE: 9,\n  ScannerQRCode_ISBN10: 10,\n  ScannerQRCode_UPCA: 12,\n  ScannerQRCode_EAN13: 13,\n  ScannerQRCode_ISBN13: 14,\n  ScannerQRCode_COMPOSITE: 15,\n  ScannerQRCode_I25: 25,\n  ScannerQRCode_DATABAR: 34,\n  ScannerQRCode_DATABAR_EXP: 35,\n  ScannerQRCode_CODABAR: 38,\n  ScannerQRCode_CODE39: 39,\n  ScannerQRCode_PDF417: 57,\n  ScannerQRCode_QRCODE: 64,\n  ScannerQRCode_SQCODE: 80,\n  ScannerQRCode_CODE93: 93,\n  ScannerQRCode_CODE128: 128,\n  /*\r\n   * Please see _ScannerQRCode_get_symbol_hash() if adding\r\n   * anything after 128\r\n   */\n  /** mask for base symbol type.\r\n   * @deprecated in 0.11, remove this from existing code\r\n   */\n  ScannerQRCode_SYMBOL: 255,\n  /** 2-digit add-on flag.\r\n   * @deprecated in 0.11, a ::ScannerQRCode_EAN2 component is used for\r\n   * 2-digit GS1 add-ons\r\n   */\n  ScannerQRCode_ADDON2: 512,\n  /** 5-digit add-on flag.\r\n   * @deprecated in 0.11, a ::ScannerQRCode_EAN5 component is used for\r\n   * 5-digit GS1 add-ons\r\n   */\n  ScannerQRCode_ADDON5: 1280,\n  /** add-on flag mask.\r\n   * @deprecated in 0.11, GS1 add-ons are represented using composite\r\n   * symbols of type ::ScannerQRCode_COMPOSITE; add-on components use ::ScannerQRCode_EAN2\r\n   * or ::ScannerQRCode_EAN5\r\n   */\n  ScannerQRCode_ADDON: 1792\n};\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_NONE] = 'ScannerQRCode_NONE';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_PARTIAL] = 'ScannerQRCode_PARTIAL';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN2] = 'ScannerQRCode_EAN2';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN5] = 'ScannerQRCode_EAN5';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN8] = 'ScannerQRCode_EAN8';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_UPCE] = 'ScannerQRCode_UPCE';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ISBN10] = 'ScannerQRCode_ISBN10';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_UPCA] = 'ScannerQRCode_UPCA';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_EAN13] = 'ScannerQRCode_EAN13';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ISBN13] = 'ScannerQRCode_ISBN13';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_COMPOSITE] = 'ScannerQRCode_COMPOSITE';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_I25] = 'ScannerQRCode_I25';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_DATABAR] = 'ScannerQRCode_DATABAR';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_DATABAR_EXP] = 'ScannerQRCode_DATABAR_EXP';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODABAR] = 'ScannerQRCode_CODABAR';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE39] = 'ScannerQRCode_CODE39';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_PDF417] = 'ScannerQRCode_PDF417';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_QRCODE] = 'ScannerQRCode_QRCODE';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_SQCODE] = 'ScannerQRCode_SQCODE';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE93] = 'ScannerQRCode_CODE93';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_CODE128] = 'ScannerQRCode_CODE128';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_SYMBOL] = 'ScannerQRCode_SYMBOL';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON2] = 'ScannerQRCode_ADDON2';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON5] = 'ScannerQRCode_ADDON5';\nScannerQRCodeSymbolType[ScannerQRCodeSymbolType.ScannerQRCode_ADDON] = 'ScannerQRCode_ADDON';\n/** @enum {number} */\nconst ScannerQRCodeConfigType = {\n  ScannerQRCode_CFG_ENABLE: 0,\n  ScannerQRCode_CFG_ADD_CHECK: 1,\n  ScannerQRCode_CFG_EMIT_CHECK: 2,\n  ScannerQRCode_CFG_ASCII: 3,\n  ScannerQRCode_CFG_BINARY: 4,\n  ScannerQRCode_CFG_NUM: 5,\n  ScannerQRCode_CFG_MIN_LEN: 32,\n  ScannerQRCode_CFG_MAX_LEN: 33,\n  ScannerQRCode_CFG_UNCERTAINTY: 64,\n  ScannerQRCode_CFG_POSITION: 128,\n  ScannerQRCode_CFG_TEST_INVERTED: 129,\n  ScannerQRCode_CFG_X_DENSITY: 256,\n  ScannerQRCode_CFG_Y_DENSITY: 257\n};\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ENABLE] = 'ScannerQRCode_CFG_ENABLE';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ADD_CHECK] = 'ScannerQRCode_CFG_ADD_CHECK';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_EMIT_CHECK] = 'ScannerQRCode_CFG_EMIT_CHECK';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_ASCII] = 'ScannerQRCode_CFG_ASCII';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_BINARY] = 'ScannerQRCode_CFG_BINARY';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_NUM] = 'ScannerQRCode_CFG_NUM';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_MIN_LEN] = 'ScannerQRCode_CFG_MIN_LEN';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_MAX_LEN] = 'ScannerQRCode_CFG_MAX_LEN';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_UNCERTAINTY] = 'ScannerQRCode_CFG_UNCERTAINTY';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_POSITION] = 'ScannerQRCode_CFG_POSITION';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_TEST_INVERTED] = 'ScannerQRCode_CFG_TEST_INVERTED';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_X_DENSITY] = 'ScannerQRCode_CFG_X_DENSITY';\nScannerQRCodeConfigType[ScannerQRCodeConfigType.ScannerQRCode_CFG_Y_DENSITY] = 'ScannerQRCode_CFG_Y_DENSITY';\n/** @enum {number} */\nconst ScannerQRCodeOrientation = {\n  ScannerQRCode_ORIENT_UNKNOWN: -1,\n  ScannerQRCode_ORIENT_UP: 0,\n  ScannerQRCode_ORIENT_RIGHT: 1,\n  ScannerQRCode_ORIENT_DOWN: 2,\n  ScannerQRCode_ORIENT_LEFT: 3\n};\nScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_UNKNOWN] = 'ScannerQRCode_ORIENT_UNKNOWN';\nScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_UP] = 'ScannerQRCode_ORIENT_UP';\nScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_RIGHT] = 'ScannerQRCode_ORIENT_RIGHT';\nScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_DOWN] = 'ScannerQRCode_ORIENT_DOWN';\nScannerQRCodeOrientation[ScannerQRCodeOrientation.ScannerQRCode_ORIENT_LEFT] = 'ScannerQRCode_ORIENT_LEFT';\nclass ScannerQRCodeTypePointer {\n  /**\r\n   * @param {?} ptr\r\n   * @param {?} buf\r\n   */\n  constructor(ptr, buf) {\n    this.ptr = ptr;\n    this.ptr32 = ptr >> 2;\n    this.buf = buf;\n    this.HEAP8 = new Int8Array(buf);\n    this.HEAPU32 = new Uint32Array(buf);\n    this.HEAP32 = new Int32Array(buf);\n  }\n}\nclass ScannerQRCodeSymbolPtr extends ScannerQRCodeTypePointer {\n  /**\r\n   * @return {?}\r\n   */\n  get type() {\n    return (/** @type {?} */this.HEAPU32[this.ptr32]\n    );\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get data() {\n    /** @type {?} */\n    const len = this.HEAPU32[this.ptr32 + 4];\n    /** @type {?} */\n    const ptr = this.HEAPU32[this.ptr32 + 5];\n    return Int8Array.from(this.HEAP8.subarray(ptr, ptr + len));\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get points() {\n    /** @type {?} */\n    const len = this.HEAPU32[this.ptr32 + 7];\n    /** @type {?} */\n    const ptr = this.HEAPU32[this.ptr32 + 8];\n    /** @type {?} */\n    const ptr32 = ptr >> 2;\n    /** @type {?} */\n    const res = [];\n    for (let i = 0; i < len; ++i) {\n      /** @type {?} */\n      const x = this.HEAP32[ptr32 + i * 2];\n      /** @type {?} */\n      const y = this.HEAP32[ptr32 + i * 2 + 1];\n      res.push( /** @type {?} */{\n        x,\n        y\n      });\n    }\n    return res;\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get orientation() {\n    return this.HEAP32[this.ptr32 + 9];\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get next() {\n    /** @type {?} */\n    const ptr = this.HEAPU32[this.ptr32 + 11];\n    if (!ptr) return null;\n    return new ScannerQRCodeSymbolPtr(ptr, this.buf);\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get time() {\n    return this.HEAPU32[this.ptr32 + 13];\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get cacheCount() {\n    return this.HEAP32[this.ptr32 + 14];\n  }\n  /**\r\n   * @return {?}\r\n   */\n  get quality() {\n    return this.HEAP32[this.ptr32 + 15];\n  }\n}\nclass SymbolSetPtr extends ScannerQRCodeTypePointer {\n  /**\r\n   * @return {?}\r\n   */\n  get head() {\n    /** @type {?} */\n    const ptr = this.HEAPU32[this.ptr32 + 2];\n    if (!ptr) return null;\n    return new ScannerQRCodeSymbolPtr(ptr, this.buf);\n  }\n}\nclass ScannerQRCodeResult {\n  /**\r\n   * @private\r\n   * @param {?} ptr\r\n   */\n  constructor(ptr) {\n    this.value = '';\n    this.type = ptr.type;\n    this.typeName = ScannerQRCodeSymbolType[this.type];\n    this.data = ptr.data;\n    this.points = ptr.points;\n    this.orientation = ptr.orientation;\n    this.time = ptr.time;\n    this.cacheCount = ptr.cacheCount;\n    this.quality = ptr.quality;\n  }\n  /**\r\n   * @param {?} ptr\r\n   * @param {?} buf\r\n   * @return {?}\r\n   */\n  static createSymbolsFromPtr(ptr, buf) {\n    if (ptr == 0) return [];\n    /** @type {?} */\n    const set = new SymbolSetPtr(ptr, buf);\n    /** @type {?} */\n    let symbol = set.head;\n    /** @type {?} */\n    const res = [];\n    while (symbol !== null) {\n      res.push(new ScannerQRCodeResult(symbol));\n      symbol = symbol.next;\n    }\n    return res;\n  }\n  /**\r\n   * @param {?=} encoding\r\n   * @return {?}\r\n   */\n  decode(encoding) {\n    /** @type {?} */\n    const decoder = new TextDecoder(encoding);\n    return decoder.decode(this.data);\n  }\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\nlet NgxScannerQrcodeModule = /*#__PURE__*/(() => {\n  class NgxScannerQrcodeModule {}\n  NgxScannerQrcodeModule.ɵfac = function NgxScannerQrcodeModule_Factory(t) {\n    return new (t || NgxScannerQrcodeModule)();\n  };\n  NgxScannerQrcodeModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxScannerQrcodeModule\n  });\n  NgxScannerQrcodeModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [NgxScannerQrcodeService]\n  });\n  return NgxScannerQrcodeModule;\n})();\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxScannerQrcodeModule, {\n    declarations: [NgxScannerQrcodeComponent],\n    exports: [NgxScannerQrcodeComponent]\n  });\n})();\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { NgxScannerQrcodeService, NgxScannerQrcodeComponent, ScannerQRCodeSymbolType, ScannerQRCodeConfigType, ScannerQRCodeOrientation, ScannerQRCodeResult, NgxScannerQrcodeModule };\n\n//# sourceMappingURL=ngx-scanner-qrcode.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}