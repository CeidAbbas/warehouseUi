import { Component, Input, Directive, ViewContainerRef, NgModule } from '@angular/core';
import { __awaiter } from 'tslib';
import qrcode from 'qrcode';
import { CommonModule } from '@angular/common';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';

function QrCodeComponent_canvas_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "canvas", 1);
} if (rf & 2) {
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("qrCode", ctx_r0.value)("qrCodeErrorCorrectionLevel", ctx_r0.errorCorrectionLevel)("qrCodeCenterImageSrc", ctx_r0.centerImageSrc)("qrCodeCenterImageWidth", ctx_r0.centerImageSize)("qrCodeCenterImageHeight", ctx_r0.centerImageSize)("qrCodeMargin", ctx_r0.margin)("width", ctx_r0.size)("height", ctx_r0.size);
} }
class QrCodeComponent {
}
QrCodeComponent.ɵfac = function QrCodeComponent_Factory(t) { return new (t || QrCodeComponent)(); };
QrCodeComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: QrCodeComponent, selectors: [["qr-code"]], inputs: { value: "value", size: "size", errorCorrectionLevel: "errorCorrectionLevel", centerImageSrc: "centerImageSrc", centerImageSize: "centerImageSize", margin: "margin" }, decls: 1, vars: 1, consts: [[3, "qrCode", "qrCodeErrorCorrectionLevel", "qrCodeCenterImageSrc", "qrCodeCenterImageWidth", "qrCodeCenterImageHeight", "qrCodeMargin", "width", "height", 4, "ngIf"], [3, "qrCode", "qrCodeErrorCorrectionLevel", "qrCodeCenterImageSrc", "qrCodeCenterImageWidth", "qrCodeCenterImageHeight", "qrCodeMargin", "width", "height"]], template: function QrCodeComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, QrCodeComponent_canvas_0_Template, 1, 8, "canvas", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.value);
    } }, directives: function () { return [ɵngcc1.NgIf, QrCodeDirective]; }, encapsulation: 2 });
QrCodeComponent.propDecorators = {
    value: [{ type: Input }],
    size: [{ type: Input }],
    errorCorrectionLevel: [{ type: Input }],
    centerImageSrc: [{ type: Input }],
    centerImageSize: [{ type: Input }],
    margin: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(QrCodeComponent, [{
        type: Component,
        args: [{
                selector: "qr-code",
                template: `
    <canvas *ngIf="value"
            [qrCode]="value"
            [qrCodeErrorCorrectionLevel]="errorCorrectionLevel"
            [qrCodeCenterImageSrc]="centerImageSrc"
            [qrCodeCenterImageWidth]="centerImageSize"
            [qrCodeCenterImageHeight]="centerImageSize"
            [qrCodeMargin]="margin"
            [width]="size"
            [height]="size">
    </canvas>
  `
            }]
    }], null, { value: [{
            type: Input
        }], size: [{
            type: Input
        }], errorCorrectionLevel: [{
            type: Input
        }], centerImageSrc: [{
            type: Input
        }], centerImageSize: [{
            type: Input
        }], margin: [{
            type: Input
        }] }); })();

class QrCodeDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        // tslint:disable-next-line:no-input-rename
        this.errorCorrectionLevel = QrCodeDirective.DEFAULT_ERROR_CORRECTION_LEVEL;
        // tslint:disable-next-line:no-input-rename
        this.margin = 16;
    }
    ngOnChanges() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.value) {
                return;
            }
            if (this.version && this.version > 40) {
                console.warn("[qrCode] max version is 40, clamping");
                this.version = 40;
            }
            else if (this.version && this.version < 1) {
                console.warn("[qrCode] min version is 1, clamping");
                this.version = 1;
            }
            else if (this.version !== undefined && isNaN(this.version)) {
                console.warn("[qrCode] version should be set to a number, defaulting to auto");
                this.version = undefined;
            }
            const canvas = this.viewContainerRef.element.nativeElement;
            if (!canvas) {
                // native element not available on server side rendering
                return;
            }
            const context = canvas.getContext("2d");
            if (context) {
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            }
            const errorCorrectionLevel = (_a = this.errorCorrectionLevel) !== null && _a !== void 0 ? _a : QrCodeDirective.DEFAULT_ERROR_CORRECTION_LEVEL;
            yield qrcode
                .toCanvas(canvas, this.value, {
                version: this.version,
                errorCorrectionLevel,
                width: this.width,
                margin: this.margin,
            });
            const centerImageSrc = this.centerImageSrc;
            const centerImageWidth = getIntOrDefault(this.centerImageWidth, QrCodeDirective.DEFAULT_CENTER_IMAGE_SIZE);
            const centerImageHeight = getIntOrDefault(this.centerImageHeight, QrCodeDirective.DEFAULT_CENTER_IMAGE_SIZE);
            if (centerImageSrc && context) {
                if (!this.centerImage) {
                    this.centerImage = new Image(centerImageWidth, centerImageHeight);
                }
                if (centerImageSrc !== ((_b = this.centerImage) === null || _b === void 0 ? void 0 : _b.src)) {
                    this.centerImage.src = centerImageSrc;
                }
                if (centerImageWidth !== this.centerImage.width) {
                    this.centerImage.width = centerImageWidth;
                }
                if (centerImageHeight !== this.centerImage.height) {
                    this.centerImage.height = centerImageHeight;
                }
                const centerImage = this.centerImage;
                centerImage.onload = () => {
                    context.drawImage(centerImage, canvas.width / 2 - centerImageWidth / 2, canvas.height / 2 - centerImageHeight / 2, centerImageWidth, centerImageHeight);
                };
            }
        });
    }
}
QrCodeDirective.ɵfac = function QrCodeDirective_Factory(t) { return new (t || QrCodeDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
QrCodeDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: QrCodeDirective, selectors: [["canvas", "qrCode", ""]], inputs: { errorCorrectionLevel: ["qrCodeErrorCorrectionLevel", "errorCorrectionLevel"], margin: ["qrCodeMargin", "margin"], value: ["qrCode", "value"], version: ["qrCodeVersion", "version"], width: "width", height: "height", centerImageSrc: ["qrCodeCenterImageSrc", "centerImageSrc"], centerImageWidth: ["qrCodeCenterImageWidth", "centerImageWidth"], centerImageHeight: ["qrCodeCenterImageHeight", "centerImageHeight"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
QrCodeDirective.DEFAULT_ERROR_CORRECTION_LEVEL = "M";
QrCodeDirective.DEFAULT_CENTER_IMAGE_SIZE = 40;
QrCodeDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
QrCodeDirective.propDecorators = {
    value: [{ type: Input, args: ["qrCode",] }],
    version: [{ type: Input, args: ["qrCodeVersion",] }],
    errorCorrectionLevel: [{ type: Input, args: ["qrCodeErrorCorrectionLevel",] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    centerImageSrc: [{ type: Input, args: ["qrCodeCenterImageSrc",] }],
    centerImageWidth: [{ type: Input, args: ["qrCodeCenterImageWidth",] }],
    centerImageHeight: [{ type: Input, args: ["qrCodeCenterImageHeight",] }],
    margin: [{ type: Input, args: ["qrCodeMargin",] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(QrCodeDirective, [{
        type: Directive,
        args: [{
                // tslint:disable-next-line:directive-selector
                selector: `canvas[qrCode]`
            }]
    }], function () { return [{ type: ɵngcc0.ViewContainerRef }]; }, { errorCorrectionLevel: [{
            type: Input,
            args: ["qrCodeErrorCorrectionLevel"]
        }], margin: [{
            type: Input,
            args: ["qrCodeMargin"]
        }], value: [{
            type: Input,
            args: ["qrCode"]
        }], version: [{
            type: Input,
            args: ["qrCodeVersion"]
        }], width: [{
            type: Input
        }], height: [{
            type: Input
        }], centerImageSrc: [{
            type: Input,
            args: ["qrCodeCenterImageSrc"]
        }], centerImageWidth: [{
            type: Input,
            args: ["qrCodeCenterImageWidth"]
        }], centerImageHeight: [{
            type: Input,
            args: ["qrCodeCenterImageHeight"]
        }] }); })();
function getIntOrDefault(value, defaultValue) {
    if (value === undefined || value === "") {
        return defaultValue;
    }
    if (typeof value === "string") {
        return parseInt(value, 10);
    }
    return value;
}

class QrCodeModule {
}
QrCodeModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: QrCodeModule });
QrCodeModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function QrCodeModule_Factory(t) { return new (t || QrCodeModule)(); }, imports: [[
            CommonModule,
        ]] });
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(QrCodeModule, { declarations: function () { return [QrCodeComponent, QrCodeDirective]; }, imports: function () { return [CommonModule]; }, exports: function () { return [QrCodeComponent, QrCodeDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(QrCodeModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    QrCodeComponent,
                    QrCodeDirective,
                ],
                imports: [
                    CommonModule,
                ],
                exports: [
                    QrCodeComponent,
                    QrCodeDirective,
                ]
            }]
    }], null, null); })();

/*
 * Public API Surface of ng-qrcode
 */

/**
 * Generated bundle index. Do not edit.
 */

export { QrCodeComponent, QrCodeDirective, QrCodeModule };

//# sourceMappingURL=ng-qrcode.js.map