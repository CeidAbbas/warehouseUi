import { __awaiter } from "tslib";
import { Directive, Input, ViewContainerRef } from "@angular/core";
import qrcode from "qrcode";
export class QrCodeDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
        // tslint:disable-next-line:no-input-rename
        this.errorCorrectionLevel = QrCodeDirective.DEFAULT_ERROR_CORRECTION_LEVEL;
        // tslint:disable-next-line:no-input-rename
        this.margin = 16;
    }
    ngOnChanges() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.value) {
                return;
            }
            if (this.version && this.version > 40) {
                console.warn("[qrCode] max version is 40, clamping");
                this.version = 40;
            }
            else if (this.version && this.version < 1) {
                console.warn("[qrCode] min version is 1, clamping");
                this.version = 1;
            }
            else if (this.version !== undefined && isNaN(this.version)) {
                console.warn("[qrCode] version should be set to a number, defaulting to auto");
                this.version = undefined;
            }
            const canvas = this.viewContainerRef.element.nativeElement;
            if (!canvas) {
                // native element not available on server side rendering
                return;
            }
            const context = canvas.getContext("2d");
            if (context) {
                context.clearRect(0, 0, context.canvas.width, context.canvas.height);
            }
            const errorCorrectionLevel = (_a = this.errorCorrectionLevel) !== null && _a !== void 0 ? _a : QrCodeDirective.DEFAULT_ERROR_CORRECTION_LEVEL;
            yield qrcode
                .toCanvas(canvas, this.value, {
                version: this.version,
                errorCorrectionLevel,
                width: this.width,
                margin: this.margin,
            });
            const centerImageSrc = this.centerImageSrc;
            const centerImageWidth = getIntOrDefault(this.centerImageWidth, QrCodeDirective.DEFAULT_CENTER_IMAGE_SIZE);
            const centerImageHeight = getIntOrDefault(this.centerImageHeight, QrCodeDirective.DEFAULT_CENTER_IMAGE_SIZE);
            if (centerImageSrc && context) {
                if (!this.centerImage) {
                    this.centerImage = new Image(centerImageWidth, centerImageHeight);
                }
                if (centerImageSrc !== ((_b = this.centerImage) === null || _b === void 0 ? void 0 : _b.src)) {
                    this.centerImage.src = centerImageSrc;
                }
                if (centerImageWidth !== this.centerImage.width) {
                    this.centerImage.width = centerImageWidth;
                }
                if (centerImageHeight !== this.centerImage.height) {
                    this.centerImage.height = centerImageHeight;
                }
                const centerImage = this.centerImage;
                centerImage.onload = () => {
                    context.drawImage(centerImage, canvas.width / 2 - centerImageWidth / 2, canvas.height / 2 - centerImageHeight / 2, centerImageWidth, centerImageHeight);
                };
            }
        });
    }
}
QrCodeDirective.DEFAULT_ERROR_CORRECTION_LEVEL = "M";
QrCodeDirective.DEFAULT_CENTER_IMAGE_SIZE = 40;
QrCodeDirective.decorators = [
    { type: Directive, args: [{
                // tslint:disable-next-line:directive-selector
                selector: `canvas[qrCode]`,
            },] }
];
QrCodeDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];
QrCodeDirective.propDecorators = {
    value: [{ type: Input, args: ["qrCode",] }],
    version: [{ type: Input, args: ["qrCodeVersion",] }],
    errorCorrectionLevel: [{ type: Input, args: ["qrCodeErrorCorrectionLevel",] }],
    width: [{ type: Input }],
    height: [{ type: Input }],
    centerImageSrc: [{ type: Input, args: ["qrCodeCenterImageSrc",] }],
    centerImageWidth: [{ type: Input, args: ["qrCodeCenterImageWidth",] }],
    centerImageHeight: [{ type: Input, args: ["qrCodeCenterImageHeight",] }],
    margin: [{ type: Input, args: ["qrCodeMargin",] }]
};
function getIntOrDefault(value, defaultValue) {
    if (value === undefined || value === "") {
        return defaultValue;
    }
    if (typeof value === "string") {
        return parseInt(value, 10);
    }
    return value;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicXItY29kZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9uZy1xcmNvZGUvc3JjL2xpYi9xci1jb2RlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFFLFNBQVMsRUFBRSxLQUFLLEVBQWEsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUE7QUFDN0UsT0FBTyxNQUFNLE1BQU0sUUFBUSxDQUFBO0FBTzNCLE1BQU0sT0FBTyxlQUFlO0lBNkIxQixZQUNVLGdCQUFrQztRQUFsQyxxQkFBZ0IsR0FBaEIsZ0JBQWdCLENBQWtCO1FBbkI1QywyQ0FBMkM7UUFDTix5QkFBb0IsR0FBK0IsZUFBZSxDQUFDLDhCQUE4QixDQUFBO1FBWXRJLDJDQUEyQztRQUNwQixXQUFNLEdBQUcsRUFBRSxDQUFBO0lBT2xDLENBQUM7SUFFSyxXQUFXOzs7WUFDZixJQUFJLENBQUMsSUFBSSxDQUFDLEtBQUssRUFBRTtnQkFDZixPQUFNO2FBQ1A7WUFFRCxJQUFJLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLEVBQUU7Z0JBQ3JDLE9BQU8sQ0FBQyxJQUFJLENBQUMsc0NBQXNDLENBQUMsQ0FBQTtnQkFDcEQsSUFBSSxDQUFDLE9BQU8sR0FBRyxFQUFFLENBQUE7YUFDbEI7aUJBQU0sSUFBSSxJQUFJLENBQUMsT0FBTyxJQUFJLElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxFQUFFO2dCQUMzQyxPQUFPLENBQUMsSUFBSSxDQUFDLHFDQUFxQyxDQUFDLENBQUE7Z0JBQ25ELElBQUksQ0FBQyxPQUFPLEdBQUcsQ0FBQyxDQUFBO2FBQ2pCO2lCQUFNLElBQUksSUFBSSxDQUFDLE9BQU8sS0FBSyxTQUFTLElBQUksS0FBSyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsRUFBRTtnQkFDNUQsT0FBTyxDQUFDLElBQUksQ0FBQyxnRUFBZ0UsQ0FBQyxD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LEtBQUssU0FBQyxzQkFBc0I7K0JBRTVCLEtBQUssU0FBQyx3QkFBd0I7Z0NBRTlCLEtBQUssU0FBQyx5QkFBeUI7cUJBRy9CLEtBQUssU0FBQyxjQUFjOztBQXFGdkIsU0FBUyxlQUFlLENBQUMsS0FBa0MsRUFBRSxZQUFvQjtJQUMvRSxJQUFJLEtBQUssS0FBSyxTQUFTLElBQUksS0FBSyxLQUFLLEVBQUUsRUFBRTtRQUN2QyxPQUFPLFlBQVksQ0FBQTtLQUNwQjtJQUVELElBQUksT0FBTyxLQUFLLEtBQUssUUFBUSxFQUFFO1FBQzdCLE9BQU8sUUFBUSxDQUFDLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQTtLQUMzQjtJQUVELE9BQU8sS0FBSyxDQUFBO0FBQ2QsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIE9uQ2hhbmdlcywgVmlld0NvbnRhaW5lclJlZiB9IGZyb20gXCJAYW5ndWxhci9jb3JlXCJcbmltcG9ydCBxcmNvZGUgZnJvbSBcInFyY29kZVwiXG5pbXBvcnQgeyBRckNvZGVFcnJvckNvcnJlY3Rpb25MZXZlbCB9IGZyb20gXCIuL3R5cGVzXCJcblxuQERpcmVjdGl2ZSh7XG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpkaXJlY3RpdmUtc2VsZWN0b3JcbiAgc2VsZWN0b3I6IGBjYW52YXNbcXJDb2RlXWAsXG59KVxuZXhwb3J0IGNsYXNzIFFyQ29kZURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uQ2hhbmdlcyB7XG5cbiAgc3RhdGljIHJlYWRvbmx5IERFRkFVTFRfRVJST1JfQ09SUkVDVElPTl9MRVZFTDogUXJDb2RlRXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSBcIk1cIlxuICBzdGF0aWMgcmVhZG9ubHkgREVGQVVMVF9DRU5URVJfSU1BR0VfU0laRSA9IDQwXG5cbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoXCJxckNvZGVcIikgdmFsdWUhOiBzdHJpbmdcblxuICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8taW5wdXQtcmVuYW1lXG4gIEBJbnB1dChcInFyQ29kZVZlcnNpb25cIikgdmVyc2lvbj86IG51bWJlclxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgQElucHV0KFwicXJDb2RlRXJyb3JDb3JyZWN0aW9uTGV2ZWxcIikgZXJyb3JDb3JyZWN0aW9uTGV2ZWw6IFFyQ29kZUVycm9yQ29ycmVjdGlvbkxldmVsID0gUXJDb2RlRGlyZWN0aXZlLkRFRkFVTFRfRVJST1JfQ09SUkVDVElPTl9MRVZFTFxuXG4gIEBJbnB1dCgpIHdpZHRoPzogbnVtYmVyXG4gIEBJbnB1dCgpIGhlaWdodD86IG51bWJlclxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgQElucHV0KFwicXJDb2RlQ2VudGVySW1hZ2VTcmNcIikgY2VudGVySW1hZ2VTcmM/OiBzdHJpbmdcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoXCJxckNvZGVDZW50ZXJJbWFnZVdpZHRoXCIpIGNlbnRlckltYWdlV2lkdGg/OiBudW1iZXIgfCBzdHJpbmdcbiAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWlucHV0LXJlbmFtZVxuICBASW5wdXQoXCJxckNvZGVDZW50ZXJJbWFnZUhlaWdodFwiKSBjZW50ZXJJbWFnZUhlaWdodD86IG51bWJlciB8IHN0cmluZ1xuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbnB1dC1yZW5hbWVcbiAgQElucHV0KFwicXJDb2RlTWFyZ2luXCIpIG1hcmdpbiA9IDE2XG5cbiAgcHJpdmF0ZSBjZW50ZXJJbWFnZT86IEhUTUxJbWFnZUVsZW1lbnRcblxuICBjb25zdHJ1Y3RvcihcbiAgICBwcml2YXRlIHZpZXdDb250YWluZXJSZWY6IFZpZXdDb250YWluZXJSZWYsXG4gICkge1xuICB9XG5cbiAgYXN5bmMgbmdPbkNoYW5nZXMoKSB7XG4gICAgaWYgKCF0aGlzLnZhbHVlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBpZiAodGhpcy52ZXJzaW9uICYmIHRoaXMudmVyc2lvbiA+IDQwKSB7XG4gICAgICBjb25zb2xlLndhcm4oXCJbcXJDb2RlXSBtYXggdmVyc2lvbiBpcyA0MCwgY2xhbXBpbmdcIilcbiAgICAgIHRoaXMudmVyc2lvbiA9IDQwXG4gICAgfSBlbHNlIGlmICh0aGlzLnZlcnNpb24gJiYgdGhpcy52ZXJzaW9uIDwgMSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW3FyQ29kZV0gbWluIHZlcnNpb24gaXMgMSwgY2xhbXBpbmdcIilcbiAgICAgIHRoaXMudmVyc2lvbiA9IDFcbiAgICB9IGVsc2UgaWYgKHRoaXMudmVyc2lvbiAhPT0gdW5kZWZpbmVkICYmIGlzTmFOKHRoaXMudmVyc2lvbikpIHtcbiAgICAgIGNvbnNvbGUud2FybihcIltxckNvZGVdIHZlcnNpb24gc2hvdWxkIGJlIHNldCB0byBhIG51bWJlciwgZGVmYXVsdGluZyB0byBhdXRvXCIpXG4gICAgICB0aGlzLnZlcnNpb24gPSB1bmRlZmluZWRcbiAgICB9XG5cbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuZWxlbWVudC5uYXRpdmVFbGVtZW50IGFzIEhUTUxDYW52YXNFbGVtZW50IHwgbnVsbFxuXG4gICAgaWYgKCFjYW52YXMpIHtcbiAgICAgIC8vIG5hdGl2ZSBlbGVtZW50IG5vdCBhdmFpbGFibGUgb24gc2VydmVyIHNpZGUgcmVuZGVyaW5nXG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICBjb25zdCBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKVxuXG4gICAgaWYgKGNvbnRleHQpIHtcbiAgICAgIGNvbnRleHQuY2xlYXJSZWN0KDAsIDAsIGNvbnRleHQuY2FudmFzLndpZHRoLCBjb250ZXh0LmNhbnZhcy5oZWlnaHQpXG4gICAgfVxuXG4gICAgY29uc3QgZXJyb3JDb3JyZWN0aW9uTGV2ZWwgPSB0aGlzLmVycm9yQ29ycmVjdGlvbkxldmVsID8/IFFyQ29kZURpcmVjdGl2ZS5ERUZBVUxUX0VSUk9SX0NPUlJFQ1RJT05fTEVWRUxcblxuICAgIGF3YWl0IHFyY29kZVxuICAgICAgLnRvQ2FudmFzKGNhbnZhcywgdGhpcy52YWx1ZSwge1xuICAgICAgICB2ZXJzaW9uOiB0aGlzLnZlcnNpb24sXG4gICAgICAgIGVycm9yQ29ycmVjdGlvbkxldmVsLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCxcbiAgICAgICAgbWFyZ2luOiB0aGlzLm1hcmdpbixcbiAgICAgIH0pXG5cbiAgICBjb25zdCBjZW50ZXJJbWFnZVNyYyA9IHRoaXMuY2VudGVySW1hZ2VTcmNcbiAgICBjb25zdCBjZW50ZXJJbWFnZVdpZHRoID0gZ2V0SW50T3JEZWZhdWx0KHRoaXMuY2VudGVySW1hZ2VXaWR0aCwgUXJDb2RlRGlyZWN0aXZlLkRFRkFVTFRfQ0VOVEVSX0lNQUdFX1NJWkUpXG4gICAgY29uc3QgY2VudGVySW1hZ2VIZWlnaHQgPSBnZXRJbnRPckRlZmF1bHQodGhpcy5jZW50ZXJJbWFnZUhlaWdodCwgUXJDb2RlRGlyZWN0aXZlLkRFRkFVTFRfQ0VOVEVSX0lNQUdFX1NJWkUpXG5cbiAgICBpZiAoY2VudGVySW1hZ2VTcmMgJiYgY29udGV4dCkge1xuXG4gICAgICBpZiAoIXRoaXMuY2VudGVySW1hZ2UpIHtcbiAgICAgICAgdGhpcy5jZW50ZXJJbWFnZSA9IG5ldyBJbWFnZShjZW50ZXJJbWFnZVdpZHRoLCBjZW50ZXJJbWFnZUhlaWdodClcbiAgICAgIH1cblxuICAgICAgaWYgKGNlbnRlckltYWdlU3JjICE9PSB0aGlzLmNlbnRlckltYWdlPy5zcmMpIHtcbiAgICAgICAgdGhpcy5jZW50ZXJJbWFnZS5zcmMgPSBjZW50ZXJJbWFnZVNyY1xuICAgICAgfVxuXG4gICAgICBpZiAoY2VudGVySW1hZ2VXaWR0aCAhPT0gdGhpcy5jZW50ZXJJbWFnZS53aWR0aCkge1xuICAgICAgICB0aGlzLmNlbnRlckltYWdlLndpZHRoID0gY2VudGVySW1hZ2VXaWR0aFxuICAgICAgfVxuXG4gICAgICBpZiAoY2VudGVySW1hZ2VIZWlnaHQgIT09IHRoaXMuY2VudGVySW1hZ2UuaGVpZ2h0KSB7XG4gICAgICAgIHRoaXMuY2VudGVySW1hZ2UuaGVpZ2h0ID0gY2VudGVySW1hZ2VIZWlnaHRcbiAgICAgIH1cblxuICAgICAgY29uc3QgY2VudGVySW1hZ2UgPSB0aGlzLmNlbnRlckltYWdlXG5cbiAgICAgIGNlbnRlckltYWdlLm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgY29udGV4dC5kcmF3SW1hZ2UoXG4gICAgICAgICAgY2VudGVySW1hZ2UsXG4gICAgICAgICAgY2FudmFzLndpZHRoIC8gMiAtIGNlbnRlckltYWdlV2lkdGggLyAyLFxuICAgICAgICAgIGNhbnZhcy5oZWlnaHQgLyAyIC0gY2VudGVySW1hZ2VIZWlnaHQgLyAyLCBjZW50ZXJJbWFnZVdpZHRoLCBjZW50ZXJJbWFnZUhlaWdodCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgIH1cblxuICB9XG5cbn1cblxuZnVuY3Rpb24gZ2V0SW50T3JEZWZhdWx0KHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCB1bmRlZmluZWQsIGRlZmF1bHRWYWx1ZTogbnVtYmVyKTogbnVtYmVyIHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHwgdmFsdWUgPT09IFwiXCIpIHtcbiAgICByZXR1cm4gZGVmYXVsdFZhbHVlXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHBhcnNlSW50KHZhbHVlLCAxMClcbiAgfVxuXG4gIHJldHVybiB2YWx1ZVxufVxuIl19